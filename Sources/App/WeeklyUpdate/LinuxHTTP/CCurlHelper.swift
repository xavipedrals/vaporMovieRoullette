//
//  File.swift
//  
//
//  Created by Xavier Pedrals CamprubÃ­ on 29/10/2020.
//

import Foundation
import CCurl
import TelegramBotSDK

class CCurlHelper {
    
    class WriteCallbackData {
        var data = Data()
    }
    
    private let writeFunction: curl_write_callback = { (ptr, size, nmemb, userdata) -> Int in
        let count = size * nmemb
        if let writeCallbackDataPointer = userdata?.assumingMemoryBound(to: WriteCallbackData.self) {
            let writeCallbackData = writeCallbackDataPointer.pointee
            ptr?.withMemoryRebound(to: UInt8.self, capacity: count) {
                writeCallbackData.data.append(&$0.pointee, count: count)
            }
        }
        return count
    }
    
    func doRequest(endpoint: String, headers: [String], completion: @escaping (Data?) -> ()) {
//        print("REQUEST INFO")
//        print(endpoint)
//        print(headers)
        DispatchQueue.global().async {
            guard let curl = curl_easy_init() else {
                print("ERROR ON CURL INIT")
                return
            }
            curl_easy_setopt_string(curl, CURLOPT_URL, endpoint)
            
            var curlHeaders: UnsafeMutablePointer<curl_slist>? = nil
            for h in headers {
                curlHeaders = curl_slist_append(curlHeaders, h)
            }
            curl_easy_setopt_slist(curl, CURLOPT_HTTPHEADER, curlHeaders)
            
            curl_easy_setopt_write_function(curl, CURLOPT_WRITEFUNCTION, self.writeFunction)
            var callbackData = WriteCallbackData()
            curl_easy_setopt_pointer(curl, CURLOPT_WRITEDATA, &callbackData)
            let res = curl_easy_perform(curl)
//            print(callbackData.data.toString())
            var httpCode: Int = 0
            guard CURLE_OK == curl_easy_getinfo_long(curl, CURLINFO_RESPONSE_CODE, &httpCode) else {
    //            reportCurlError(code: code, completion: completion)
                print("CURL error code -> \(res)")
                return
            }
            curl_easy_cleanup(curl)
            completion(callbackData.data)
        }
    }
    
    //Autogenerated code from Postman, God bless Postman
//    func sida() {
//        DispatchQueue.global().async {
//            guard let curl = curl_easy_init() else {
//                print("ERROR ON CURL INIT")
//                return
//            }
//            curl_easy_setopt_string(curl, CURLOPT_URL, "https://unogs-unogs-v1.p.rapidapi.com/aaapi.cgi?q=-!1900,2018-!0,5-!0,10-!0-!Movie-!Any-!Any-!gt100-!&t=ns&cl=39&st=adv&ob=Relevance&p=2&sa=and%20")
//
//            var headers: UnsafeMutablePointer<curl_slist>? = nil
//            headers = curl_slist_append(headers, "X-RapidAPI-Key: Pg39B9YjdemshbfsF4A9Zadzn129p19HO7wjsnDtkTLedgooCl")
//            curl_easy_setopt_slist(curl, CURLOPT_HTTPHEADER, headers)
//
//            let writeFunction: curl_write_callback = { (ptr, size, nmemb, userdata) -> Int in
//                let count = size * nmemb
//                if let writeCallbackDataPointer = userdata?.assumingMemoryBound(to: WriteCallbackData.self) {
//                    let writeCallbackData = writeCallbackDataPointer.pointee
//                    ptr?.withMemoryRebound(to: UInt8.self, capacity: count) {
//                        writeCallbackData.data.append(&$0.pointee, count: count)
//                    }
//                }
//                return count
//            }
//            curl_easy_setopt_write_function(curl, CURLOPT_WRITEFUNCTION, writeFunction)
//            var callbackData = WriteCallbackData()
//            curl_easy_setopt_pointer(curl, CURLOPT_WRITEDATA, &callbackData)
//            let res = curl_easy_perform(curl);
//            print(res)
//            print(callbackData.data.toString())
//
//            curl_easy_cleanup(curl);
//        }
//    }
    
//    func startDataTaskForEndpoint<T: Decodable>(_ endpoint: String, parameters: [String: Encodable?], resultType: T.Type, completion: @escaping DataTaskCompletion) {
//        let endpointUrl = urlForEndpoint(endpoint)
//        
//        // If parameters contain values of type InputFile, use  multipart/form-data for sending them.
//        var hasAttachments = false
//        for value in parameters.values {
//            if value is InputFile {
//                hasAttachments = true
//                break
//            }
//            
//            if value is InputFileOrString {
//                if case InputFileOrString.inputFile = (value as! InputFileOrString) {
//                    hasAttachments = true
//                    break
//                }
//            }
//        }
//        
//        let contentType: String
//        var requestDataOrNil: Data?
//        if hasAttachments {
//            let boundary = HTTPUtils.generateBoundaryString()
//            contentType = "multipart/form-data; boundary=\(boundary)"
//            requestDataOrNil = HTTPUtils.createMultipartFormDataBody(with: parameters, boundary: boundary)
//            //try! requestDataOrNil!.write(to: URL(fileURLWithPath: "/tmp/dump.bin"))
//            print("endpoint: \(endpoint), sending parameters as multipart/form-data")
//        } else {
//            contentType = "application/x-www-form-urlencoded"
//            let encoded = HTTPUtils.formUrlencode(parameters)
//            requestDataOrNil = encoded.data(using: .utf8)
//            print("endpoint: \(endpoint), data: \(encoded)")
//        }
//        requestDataOrNil?.append(0)
//
//        guard let requestData = requestDataOrNil else {
//            completion(nil, .invalidRequest)
//            return
//        }
//        // -1 for '\0'
//        let byteCount = requestData.count - 1
//        
//        DispatchQueue.global().async {
//            requestData.withUnsafeBytes { (unsafeRawBufferPointer) -> Void in
//                let unsafeBufferPointer = unsafeRawBufferPointer.bindMemory(to: UInt8.self).baseAddress!
//                self.curlPerformRequest(endpointUrl: endpointUrl, contentType: contentType, resultType: resultType, requestBytes: unsafeBufferPointer, byteCount: byteCount, completion: completion)
//            }
//        }
//    }
//    
//    /// Note: performed on global queue
//    private func curlPerformRequest<T: Decodable>(endpointUrl: URL, contentType: String, resultType: T.Type, requestBytes: UnsafePointer<UInt8>, byteCount: Int, completion: @escaping (Data?, DataTaskError?) -> ()) {
//        var callbackData = WriteCallbackData()
//        
//        guard let curl = curl_easy_init() else {
//            completion(nil, .libcurlInitError)
//            return
//        }
//        defer { curl_easy_cleanup(curl) }
//        
//        curl_easy_setopt_string(curl, CURLOPT_URL, endpointUrl.absoluteString)
//        //curl_easy_setopt_int(curl, CURLOPT_SAFE_UPLOAD, 1)
//        curl_easy_setopt_int(curl, CURLOPT_POST, 1)
//        curl_easy_setopt_binary(curl, CURLOPT_POSTFIELDS, requestBytes)
//        curl_easy_setopt_int(curl, CURLOPT_POSTFIELDSIZE, Int32(byteCount))
//        
//        var headers: UnsafeMutablePointer<curl_slist>? = nil
//        headers = curl_slist_append(headers, "Content-Type: \(contentType)")
//        curl_easy_setopt_slist(curl, CURLOPT_HTTPHEADER, headers)
//        defer { curl_slist_free_all(headers) }
//        
//        let writeFunction: curl_write_callback = { (ptr, size, nmemb, userdata) -> Int in
//            let count = size * nmemb
//            if let writeCallbackDataPointer = userdata?.assumingMemoryBound(to: WriteCallbackData.self) {
//                let writeCallbackData = writeCallbackDataPointer.pointee
//                ptr?.withMemoryRebound(to: UInt8.self, capacity: count) {
//                    writeCallbackData.data.append(&$0.pointee, count: count)
//                }
//            }
//            return count
//        }
//        curl_easy_setopt_write_function(curl, CURLOPT_WRITEFUNCTION, writeFunction)
//        curl_easy_setopt_pointer(curl, CURLOPT_WRITEDATA, &callbackData)
//        //curl_easy_setopt_int(curl, CURLOPT_VERBOSE, 1)
//        let code = curl_easy_perform(curl)
//        guard code == CURLE_OK else {
////            reportCurlError(code: code, completion: completion)
//            print("CURL error code -> \(code)")
//            return
//        }
//        
//        //let result = String(data: callbackData.data, encoding: .utf8)
//        //print("CURLcode=\(code.rawValue) result=\(result.unwrapOptional)")
//        
//        guard code != CURLE_ABORTED_BY_CALLBACK else {
//            completion(nil, .libcurlAbortedByCallback)
//            return
//        }
//        
//        var httpCode: Int = 0
//        guard CURLE_OK == curl_easy_getinfo_long(curl, CURLINFO_RESPONSE_CODE, &httpCode) else {
////            reportCurlError(code: code, completion: completion)
//            print("CURL error code -> \(code)")
//            return
//        }
//        let data = callbackData.data
//        guard httpCode == 200 else {
//            completion(nil, .invalidStatusCode(statusCode: httpCode, telegramDescription: "", telegramErrorCode: 0, data: data))
//            return
//        }
//        
//        guard !data.isEmpty else {
//            completion(nil, .noDataReceived)
//            return
//        }
//        
//        completion(data, nil)
//    }
//    
//    private func reportCurlError(code: CURLcode, completion: @escaping DataTaskCompletion) {
//        let failReason = String(cString: curl_easy_strerror(code), encoding: .utf8) ?? "unknown error"
//        //print("Request failed: \(failReason)")
//        completion(nil, .libcurlError(code: code, description: failReason))
//    }
//    
//    private func urlForEndpoint(_ endpoint: String) -> URL {
//        let endpointUrlencoded = endpoint.urlQueryEncode()
//        guard let result = URL(string: endpointUrlencoded) else {
//            fatalError("Invalid URL: \(endpointUrlencoded)")
//        }
//        return result
//    }
//    
//    internal typealias DataTaskCompletion = (_ result: Decodable?, _ error: DataTaskError?)->()
}

extension Data {
    func toString() -> String {
        return String(data: self, encoding: .utf8)!
    }
}
